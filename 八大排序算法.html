<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1.冒泡排序：依次比较相邻两元素，若前一元素大于后一元素，那么交换（时间复杂度：n²，空间复杂度：1，稳定）
        // function sort(arr) {
        //     let temp
        //     let i = arr.length
        //     while (i > 0) {
        //         for (let j = 0; j < i - 1; j++) {
        //             // console.log(j);
        //             if (arr[j] > arr[j + 1]) {
        //                 temp = arr[j]
        //                 arr[j] = arr[j + 1]
        //                 arr[j + 1] = temp
        //             }
        //         }
        //         i--
        //     }
        //     return arr
        // }

        // 2.选择排序：每次循环寻找最小或最大的一项,循环结束后交换该项和首项（时间复杂度：n²，空间复杂度：1，不稳定）
        // function sort(arr) {
        //     let minIndex
        //     let temp
        //     for (let i = 0; i < arr.length; i++) {
        //         minIndex = i
        //         for (let j = i + 1; j < arr.length; j++) {
        //             if (arr[j] < arr[minIndex]) {
        //                 minIndex = j
        //             }
        //         }
        //         if (minIndex != i - 1) { //条件成立才交换，提升性能
        //             temp = arr[i]
        //             arr[i] = arr[minIndex]
        //             arr[minIndex] = temp
        //         }
        //     }
        //     return arr
        // }

        // 3.快速排序：选择第一项，将小于该项的放在左边，大于该项的放在右边。并对左右两堆数组以此类推进行处理（时间复杂度：nlogn，空间复杂度：logn，不稳定）
        // function sort(arr) {
        //     if (arr.length <= 1) {
        //         return arr;
        //     }
        //     let left = []
        //     let right = []
        //     for (let i = 1; i < arr.length; i++) {
        //         if (arr[i]< arr[0]) {
        //             left.push(arr[i])
        //         }
        //         else right.push(arr[i])
        //     }

        //     return sort(left).concat(arr[0], sort(right))
        // }

        // 4.插入排序：将数组分为已排序和未排序两部分，每次将未排序部分的第一个元素插入到已排序部分的合适位置，直至所有元素有序。（时间复杂度：n²，空间复杂度：1，稳定）
        // function sort(arr) {
        //     let temp
        //     for (let i = 1; i < arr.length; i++) {
        //         for (let j = i - 1; j >= 0 && arr[j + 1] < arr[j]; j--) {
        //             temp = arr[j]
        //             arr[j] = arr[j + 1]
        //             arr[j + 1] = temp
        //         }
        //     }
        //     return arr
        // }

        // 5.希尔排序：首先间隔为数组长度/2,然后，/4,直到为1 （时间复杂度：n²，空间复杂度：1，不稳定）
        // function sort(arr) {
        //     for (let fraction = Math.floor(arr.length / 2); fraction > 0; fraction = Math.floor(fraction / 2)) {
        //         // 插入排序，只不过间隔从1变成了fraction
        //         for (let i = fraction; i < arr.length; i++) {
        //             for (let j = i - fraction; j >= 0 && arr[j + fraction] < arr[j]; j-=fraction) {
        //                 let temp = arr[j]
        //                 arr[j] = arr[j + fraction]
        //                 arr[j + fraction] = temp
        //             }
        //         }
        //     }
        //     return arr
        // }

        // 6.归并排序: 将一个序列不断细分成若干个子序列，子序列有序后再向上合并，最终得到有序的总序列（时间复杂度：nlogn，空间复杂度：n，稳定）
        // 合并
        // function merge(left, right) {
        //     let result = []
        //     if (left.length > 0 && right.length > 0) {
        //         if (left[0] < right[0]) {
        //             result.push(left.shift())
        //         } else result.push(right.shift())
        //     }
        //     return result.concat(left, right)
        // }
        // function sort(arr) {
        //     if (arr.length<=1) {
        //         return arr
        //     }
        //     let middle = Math.floor(arr.length / 2)
        //     let left = arr.slice(0, middle)
        //     let right = arr.slice(middle)
        //     return merge(sort(left),sort(right))
        // }

        // 7.基数排序：将要排序的元素分类，也就是分配到几个“桶”中，然后串接起来，然后再根据进一步的信息再分配，再串接，以达排序的目的
        // 先对比个位数，再对比十分位，以此类推放入桶中再取出
        // 求数组中最大数有多少位（
        // 时间复杂度：d×(n+k)，空间复杂度：n+k，稳定，其中𝑛
        // n: 需要排序的元素个数。
        // d: 数字的最大位数（对于字符串，是字符串的最大长度）。
        // k: 基数（即每位数字的可能取值范围，对于十进制数，基数 k=10）
        // function maxbit(arr) {
        //     let d = 1,
        //         p = 10;
        //     for (let i = 0; i < arr.length; i++) {
        //         while (arr[i] >= p) {
        //             p *= 10;
        //             ++d;
        //         }
        //     }
        //     return d;
        // }
        // // 排序
        // function sort(arr) {
        //     let d = maxbit(arr);
        //     let temp = [] //用于存储排序后的结果;
        //     let count = [] //用于统计每个桶中元素的个数;
        //     let i, j, k;
        //     let radix = 1 //表示当前的位数;
        //     // d次排序
        //     for (i = 1; i <= d; i++) {
        //         for (j = 0; j < 10; j++) count[j] = 0;
        //         for (j = 0; j < arr.length; j++) {
        //             k = Math.floor(arr[j] / radix) % 10;
        //             count[k]++;
        //         }
        //         for (j = 1; j < 10; j++) {
        //             count[j] = count[j - 1] + count[j];
        //         }
        //         for (j = arr.length - 1; j >= 0; j--) {
        //             k = Math.floor(arr[j] / radix) % 10;
        //             temp[count[k] - 1] = arr[j];
        //             count[k]--;
        //         }
        //         for (j = 0; j < arr.length; j++) {
        //             arr[j] = temp[j];
        //         }
        //         radix *= 10;
        //     }
        //     return arr;
        // }

        // 8.堆排序：（时间复杂度：nlogn，空间复杂度：1，不稳定）
        // 实现最大堆
        function maxHeapify(arr, start, end) {
            let dad = start;
            let son = dad * 2 + 1;
            while (son <= end) {
                if (son + 1 <= end && arr[son] < arr[son + 1]) {
                    son++;
                }
                if (arr[dad] > arr[son]) {
                    return;
                } else {
                    let temp = arr[dad];
                    arr[dad] = arr[son];
                    arr[son] = temp;
                    dad = son;
                    son = dad * 2 + 1;
                }
            }
        }
        // 排序
        function sort(arr) {
            for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
                maxHeapify(arr, i, arr.length - 1);
            }
            for (let i = arr.length - 1; i > 0; i--) {
                let temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
                maxHeapify(arr, 0, i - 1);
            }
            return arr;
        }

        const arr = [75, 43, 10, 82, 91, 45, 60, 49, 18, 15, 2, 27, 85, 89, 83, 58, 32, 47, 13, 64, 14, 34, 54, 20, 79,
            41, 70, 93, 84, 51
        ]
        console.log(sort(
            arr
        )); //[2, 10, 13, 14, 15, 18, 20, 27, 32, 34, 41, 43, 45, 47, 49, 51, 54, 58, 60, 64, 70, 75, 79, 82, 83, 84, 85, 89, 91, 93]
    </script>
</body>

</html>